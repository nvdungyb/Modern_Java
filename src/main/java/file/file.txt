- 1 -
 // // Using Stream API
    List<Apple> listGreenApples = inventory.getListApples().stream().filter((Apple a) -> a.getColor().equals(AppleColor.GREEN.name())).collect(toList());

+) Phương thức filter của stream() lấy một instance của Predicate interface, tức nghĩa là lambda expression ở trên tạo một instance predicate.
+) Phương thức: collect(Collections.toList()) khác gì với toList().
            + Collections.toList() xuất hiện từ java 8 và nó trả về một List có thể thay đổi (mutable list).
            + toList() xuất hiện từ java 16 và nó trả về một list không thể thay đổi, nếu cố thay đổi thì thông báo lỗi sẽ xuất hiện.



- 2 -
    List<Apple> listRedApples = inventory.getListApples().parallelStream().filter((Apple a) -> a.getColor().equals(AppleColor.RED.name())).collect(Collectors.toList());

+) Parallelism in java and no shared mutable state
    : work only if the methods passed to library methods like filter don't interact.


- 3 - : A good principle
    When you find yourself writing nearly repeated code, try to abstract instead.


- 4 - : DRY
    Don't repeat yourself.


- 5 - : Behavior parameterization
    Nhớ rằng khách hàng luôn thay đổi requirements => Code cần có khả năng bảo trì
    _ Thay vì thêm tham số vào phương thức để đáp ứng sự thay đổi yêu cầu thì ta có cách làm tốt hơn.

    1.  Ta trừu tượng hóa phương thức cần thực hiện (predicate).
    2.  Giờ ta có thể tạo các lớp thực thi từ interface đó.
    3.  Bây giờ ta có thể truyền vào phương thức thực thi đối tượng thực hiện hành động tương ứng.
        ( Ability to tell a method to take multiple behaviors as paramters and use them internally to accomplish different behaviors.)



- 6 - : Behavior parameter
    Is great because it enables you to separate the logic of iterating the collection to filter and the behavior to apply  on each element
    of that collection. => we can reuse the same method and give it different behaviors to achieve different things.


- 7 - : Anonymous classes
    It doesn't have a name. They allow you to declare and instantiatea class at the same time.

    => Để không phải tạo lớp và khởi tạo để dùng 1 lần thì thay vào đó ta dùng anonymous class cho tiện.
    Nhưng cách này khiến code khó hiểu, khó đọc và khó bảo trì đối với trường hợp phức tạp.
    không gọn bằng việc sử dụng lambda expression.


- 8 - : Lambda expression
    A lambda expression can be understood as a concise representation of an anonymous function
    that can be passed around. It doesn't have a name, but it has a list of parameters, a body, a return type, and also possibly a list of exception
    that can be thrown.

    expression style :   (parameter) -> {statements;}


- 9 - : A functional interface
    is an interface that specific exactly one abstract method.
    It also can has many default method (method with a body that provide some default implementation for a method in case it isn't implements by a class).

=> Lambda expression let you provide the implementation of the abstract method of a functional interface directly inline
and treat the whole expression as an instance of a functional interface (an instance of a concrete implementation of the functional interface).
